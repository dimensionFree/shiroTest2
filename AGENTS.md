# gemini.md
> 说明：这是给本地/CLI/IDE 内 AI 编程助手（如 Gemini CLI、Cursor、Copilot Chat、JetBrains AI 等）使用的项目级指令。
> 目标：让 AI 生成“能合并进主分支”的代码，而不是只跑得通的 demo。
> 语言：**中文**（包括注释、提交信息草稿、PR 描述草稿等）。

---

## 0. 总体行为准则（最重要）

1) **不要编造**：不确定的 API、类名、目录结构、依赖版本，必须先搜索项目代码再写（例如先用 ripgrep / IDE 搜索）。
2) **最小改动原则**：只改与需求相关的文件；避免“大重构”。
3) **可回滚**：每次改动要能被清晰解释，必要时拆分为多个小提交。
4) **先测试后完成**：如果需求涉及业务逻辑变更或新增接口，必须补齐测试（见第 6 节）。
5) **失败要透明**：遇到编译/测试失败，要在输出里说明失败原因、定位过程和修复方案。

---

## 1. 代码风格与可读性

### 1.1 命名与结构
- 类/方法/变量命名要**表达业务意图**，避免 `data`, `info`, `tmp` 这类泛名。
- 单个方法尽量控制在 **40 行以内**（特殊情况允许，但要说明原因）。
- 拒绝“魔法值”：用常量、枚举或配置项替代。
- DTO / Entity / VO 分层明确，不要混用。

### 1.2 注释规范（中文）
- 注释只写“为什么”，不要重复代码“做了什么”。
- 复杂逻辑必须给出：
    - 背景（为什么这么做）
    - 边界条件（输入为空/异常值如何处理）
    - 例子（如必要）
- 示例（推荐写法）：
  ```java
  // 为什么：这里需要按 updateDate 倒序取最新版本，避免并发写入导致取到旧数据
  // 边界：updateDate 为空时按 createDate 兜底


## 3. API 设计与参数校验

### 3.1 参数校验要求
- **所有对外 Controller 接口必须进行参数校验**
- 可使用方案包括但不限于：
  - Bean Validation（如 `@NotNull`, `@Size`, `@Min` 等）
  - 等效的手写校验或框架校验机制
- 禁止在 Service 层才发现并处理明显的参数非法问题

### 3.2 参数校验失败的处理
- 参数校验失败时：
  - **必须返回项目统一的错误结构**
  - **不允许直接返回框架默认异常信息**（如 Spring 的默认校验错误 JSON）
- 错误信息应：
  - 对调用方友好
  - 不暴露内部实现或堆栈信息

### 3.3 API 设计原则
- 字段命名要求：
  - 命名稳定
  - 语义明确
  - 避免缩写或含糊命名
- 新增字段：
  - 优先设计为可选（optional）
  - 避免破坏现有接口兼容性
- 返回值设计：
  - 避免暴露内部实体结构（如数据库字段、内部状态字段）
  - 使用明确的 DTO / Response Object

---

## 4. 依赖管理与版本控制

- **不随意升级现有依赖版本**
- 如必须新增或升级依赖，必须明确说明：
  1) 该依赖解决了什么问题
  2) 是否存在更轻量的替代方案
  3) 是否引入 License 或安全风险
- 公共依赖版本应：
  - 优先集中管理（如 parent / BOM）
  - 避免在子模块中随意覆盖版本

---

## 5. 文档与变更记录要求

### 5.1 文档更新要求
当功能发生变更时，至少更新以下之一：
- README（若影响使用方式、启动方式或配置）
- API 文档（Swagger / OpenAPI / Markdown）
- `docs/` 目录下的业务说明文档

### 5.2 AI 输出的文档要求
AI 在输出结果时，必须提供：
- 改动文件列表
- 功能变更摘要
- 对现有行为的影响说明（如有）

---

## 6. 测试要求（新增功能必须遵守）

> **核心原则**：任何新功能追加，必须补齐  
> **Controller → Service 层的测试**

---

### 6.1 Controller 层（集成测试）

- 必须新增或更新 Controller 集成测试
- 推荐使用真实 HTTP 调用方式，例如：
  - MockMvc
  - WebTestClient
  - supertest
- 至少覆盖以下场景：
  1) 正常请求（200）
  2) 参数校验失败（400）
  3) 权限或认证失败（401 / 403，如适用）
  4) 业务异常映射（如 409 / 422）

#### 测试要求
- 使用真实 JSON 序列化 / 反序列化
- 明确断言：
  - 响应结构
  - 关键字段
- **不只断言 status code**

---

### 6.2 Service 层（单元测试）

- Service 层必须有单元测试覆盖核心业务规则
- Repository / 外部依赖必须使用 Mock
- 覆盖内容至少包括：
  1) 主流程（happy path）
  2) 边界条件（空值、重复请求、非法状态）
  3) 依赖异常时的行为（是否抛异常 / 是否降级）

#### 测试结构要求
- 推荐使用 Given / When / Then 结构：
  - Given：准备数据与 Mock 行为
  - When：执行被测方法
  - Then：断言返回值、异常或交互行为

---

### 6.3 新增功能的最低交付标准

当新增一个功能（如新增接口或扩展业务能力）时，**至少包含**：
- ✅ Controller 实现
- ✅ Service 实现
- ✅ Controller 集成测试
- ✅ Service 单元测试
- ✅ 必要的文档更新

**未满足上述条件的代码，不应视为“完成”。**

---

## 7. 输出与交付格式（AI 必须遵守）

完成任务后，必须按以下顺序输出结果：
1) 变更摘要（3~8 条）
2) 改动文件列表（按模块分组）
3) 关键实现说明（为什么这么设计）
4) 测试命令与结果
5) 潜在风险或后续优化点（仅记录，不影响合并）

---

## 8. 新增功能的标准执行流程（示例）

当需求是“新增一个新功能或接口”时，执行顺序必须是：
1) 搜索并理解现有相似实现
2) 按最小改动原则实现功能
3) 编写 Service 单元测试
4) 编写 Controller 集成测试
5) 本地测试全部通过
6) 按第 7 节格式输出交付结果
